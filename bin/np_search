#!/usr/bin/env ruby

require 'np_search/version'
require 'np_search'
require 'bio'
require 'fileutils'
require 'optparse'
require 'logger'
require 'haml'

# Search for the signal p directory with signal peptide.
signalp_dir = "#{Dir.home}/SignalPeptide"

options = {}
optparse = OptionParser.new do|opts|
  opts.banner = <<Banner

* Usage: np_search [Options] -m [Motif] -t [Input Type] -i [Input File] -o [Output Folder Name]

* Mandatory Options:

Banner

  options[:motif] = nil
  opts.on('-m', '--motif [Query Motif]', 'The query motif to be searched for.',
          'The period "." can be used to denote any character. Multiple',
          'motifs query can be used by using a pipeline character ("|")',
          'between each query and putting the motif query in speech marks',
          'e.g. "KR|RR|R..R"',
          'Advanced Users: Regular expressions are also supported.') do |motif|
    options[:motif] = motif
  end

  options[:input_type] = nil
  opts.on('-t', '--input_type [type]',
          'The type of data in the input query file. The only two options',
          'available are "genetic" and "protein".') do |input_type|
    options[:input_type] = input_type
  end

  options[:input] = nil
  opts.on('-i', '--input [file]',
          'The input file. Can be a relative or a full path.') do |input_file|
    options[:input] = input_file
  end

  options[:output_dir] = nil
  opts.on('-o', '--output [folder name]', 'The path to the output folder.',
          ' This will be created if the folder does not exist.') do |output|
    options[:output_dir] = output
  end

  opts.separator ''
  opts.separator '* Optional Options:'

  options[:cut_off] = 10
  opts.on('-c', '--cut_off N', Integer, 'Changes the default minimum Open '\
          ' Reading Frame from 10 amino acid residues to N amino acid'\
          ' residues.') do |n|
    options[:cut_off] = n
  end

  options[:signalp_file] = nil
  opts.on('-s', '--signalp_file [file]',
          'Is used to supply the signal peptide results to the program. These',
          ' signal peptide results must be created using the SignalP program',
          " (Version 4.x), downloadable from CBS. If this argument isn't ",
          ' suplied, then NpSearch will try to run a local version of the',
          ' Signal P script.') do |signalp_file|
    options[:signalp_file] = signalp_file
  end

  options[:output_all] = false
  opts.on('-a', '--output_all', 'Outputs all possible files.') do
    options[:output_all] = true
  end

  options[:extract_orf] = false
  opts.on('-e', '--extract_orf', 'Only extracts the Open Reading Frames.') do
    options[:extract_orf] = true
  end

  options[:verbose] = false
  opts.on('-v', '--verbose', 'Provides more information on each step taken'\
          ' in this program.') do
    options[:verbose] = true
  end

  opts.on('-h', '--help', 'Display this screen') do
    puts opts
    exit
  end

  opts.on('--version', 'Shows version') do
    puts NpSearch::VERSION
    exit
  end
end
optparse.parse!

############# Input Validation...##############
input_vldr = NpSearch::Validators.new(options[:verbose], optparse.help())
input_vldr.arg_vldr(options[:motif], options[:input_type], options[:input],
                    options[:output_dir])
sp_dir = input_vldr.sp_vldr(signalp_dir) if options[:signalp_file] == nil
input_vldr.orf_min_length_vldr(options[:cut_off])
input_vldr.input_type_vldr(options[:input_type])
input_vldr.input_file_vldr(options[:input])
input_vldr.output_dir_vldr(options[:output_dir])

### TODO: Convert the below into methods

if options[:input_type] == 'protein' && options[:extract_orf]
  puts 'Conflicting arguments detected: the Extract_ORF option (option "-e")'\
       ' is only available when input file contains protein data.'
  exit
end
if options[:input_type] == 'genetic' && options[:signalp_file] != nil
  puts 'Conflicting arguments detected: the signalp input option (option "-s")'\
       ' is only available when the input file contain protein data.'
  exit
end

############# Initialise Outputs...##############
to_output = NpSearch::Output.new

############# Converting input file to Bio::FastaFormat. #############
input_file = NpSearch::Input.new
input_read = input_file.read(options[:input], options[:input_type])

############# Extract_ORF #############
if options[:input_type].downcase == 'genetic'
  translater = NpSearch::Translation.new
  
  # Translate Sequences in all 6 frames
  translated_sequences = translater.translate(input_read)
  if options[:output_all]
    to_output.to_fasta('translated sequences', translated_sequences,
                       "#{options[:output_dir]}/1_protein.fa") 
  end

  # Extract all possible ORF
  orf = translater.extract_orf(translated_sequences)
  to_output.to_fasta('extracted Open Reading Frames', orf, 
                     "#{options[:output_dir]}/2_orf.fa") if options[:output_all]
  
  # Sort out the file numbering...
  j = 1 unless options[:output_all]
  j = 3 if options[:output_all]
  
  # Remove all ORF that are shorter than 10 amino acids.
  orf_clean = translater.orf_cleaner(orf, options[:cut_off])
  to_output.to_fasta('cleaned Open Reading Frames' , orf_clean,
                     "#{options[:output_dir]}/#{j}_orf_clean.fa")
end
 
if options[:extract_orf]
  puts "\nSuccess: All output files created in the directory:" \
       "#{options[:output_dir]}'.\n " 
  exit
end

############# Setting up more variables...##############
if options[:motif] == 'neuro_clv'
  motif = 'KK|KR|RR|'\
          'R..R|R....R|R......R|H..R|H....R|H......R|K..R|K....R|K......R'
else
  motif = options[:motif]
end

if options[:input_type].downcase == 'genetic'
  sp_input_file = "#{options[:output_dir]}/#{j}_orf_clean.fa"
  sp_hash = orf_clean
  i = j + 1
else # i.e. if the input is protein 
  sp_input_file = options[:input]
  sp_hash = input_read
  i = 1
end

# If a signal p output file isn't supplied.
if options[:signalp_file] == nil 
  sp_out_file = "#{options[:output_dir]}/#{i}_signalp_out.txt"
  i += 1
else
  sp_out_file = options[:signalp_file]
  i = 1
end

############# Signal P #############
signalp_test = NpSearch::Signalp.new
# Run an extenal Signal P script
if options[:signalp_file] == nil
  signalp_test.signalp(sp_dir, sp_input_file, sp_out_file)
end
# Check that the output produced is in a readable format
input_vldr.sp_version_vldr(sp_out_file)


############# Data Analysis #############
data_analysis = NpSearch::Analysis.new
identified_positives = data_analysis.sp_positives_extractor(sp_out_file,
   "#{options[:output_dir]}/#{i}_signalp_positives.txt", 
   "signalp_positives_file")
signalp = data_analysis.array_generator(identified_positives)
secretome = data_analysis.parse(signalp, sp_hash, motif)
i += 1
to_output.to_fasta("secretome", secretome,
  "#{options[:output_dir]}/#{i}_Secretome.fa")
i += 1

############# Creating Output Files #############
flattened_seq = data_analysis.flattener(secretome)
to_output.to_fasta("fasta output file", flattened_seq,
  "#{options[:output_dir]}/#{i}_output.fa")
html_hash = to_output.make_html_hash(flattened_seq, motif)
to_output.to_html(html_hash, "#{options[:output_dir]}/#{i}_output.doc")

# Success
puts # a blank line.
puts "Success: All output files created in the directory:"\
    " '#{options[:output_dir]}'."
puts # a blank line.