#!/usr/bin/env ruby

require 'np_search/version'
require 'np_search'
require 'bio'
require 'fileutils'
require 'optparse'
require 'logger'
require 'haml'

# Search for the signal p directory with signal peptide.
signalp_dir = "#{Dir.home}/SignalPeptide"

options = {}
optparse = OptionParser.new do|opts|
  opts.banner = <<Banner

* Usage: np_search [Options] -m [Motif] -t [Input Type] -i [Input File] -o [Output Folder Name]

* Mandatory Options:

Banner

  options[:motif] = nil
  opts.on('-m', '--motif [Query Motif]', 'The query motif to be searched for.',
          'The period "." can be used to denote any character. Multiple',
          'motifs query can be used by using a pipeline character ("|")',
          'between each query and putting the motif query in speech marks',
          'e.g. "KR|RR|R..R"',
          'Advanced Users: Regular expressions are also supported.') do |motif|
    options[:motif] = motif
  end

  options[:input_type] = nil
  opts.on('-t', '--input_type [type]',
          'The type of data in the input query file. The only two options',
          'available are "genetic" and "protein".') do |input_type|
    options[:input_type] = input_type
  end

  options[:input] = nil
  opts.on('-i', '--input [file]',
          'The input file. Can be a relative or a full path.') do |input_file|
    options[:input] = input_file
  end

  options[:output_dir] = nil
  opts.on('-o', '--output [folder name]', 'The path to the output folder.',
          ' This will be created if the folder does not exist.') do |output|
    options[:output_dir] = output
  end

  opts.separator ''
  opts.separator '* Optional Options:'

  options[:cut_off] = 10
  opts.on('-c', '--cut_off N', Integer, 'Changes the default minimum Open '\
          ' Reading Frame from 10 amino acid residues to N amino acid'\
          ' residues.') do |n|
    options[:cut_off] = n
  end

  options[:signalp_file] = nil
  opts.on('-s', '--signalp_file [file]',
          'Is used to supply the signal peptide results to the program. These',
          ' signal peptide results must be created using the SignalP program',
          " (Version 4.x), downloadable from CBS. If this argument isn't ",
          ' suplied, then NpSearch will try to run a local version of the',
          ' Signal P script.') do |signalp_file|
    options[:signalp_file] = signalp_file
  end

  options[:extract_orf] = false
  opts.on('-e', '--extract_orf', 'Only extracts the Open Reading Frames.') do
    options[:extract_orf] = true
  end

  options[:verbose] = false
  opts.on('-v', '--verbose', 'Provides more information on each step taken'\
          ' in this program.') do
    options[:verbose] = true
  end

  opts.on('-h', '--help', 'Display this screen') do
    puts opts
    exit
  end

  opts.on('--version', 'Shows version') do
    puts NpSearch::VERSION
    exit
  end
end
optparse.parse!

############# Argument Validation...##############
arg_vldr = NpSearch::ArgValidators.new(options[:verbose], optparse.help())
arg_vldr.arg(options[:motif], options[:input_type], options[:input],
                     options[:output_dir], options[:cut_off], 
                     options[:extract_orf], options[:signalp_file])

############# General Validation...##############
vldr = NpSearch::Validators.new
vldr.output_dir(options[:output_dir])
sp_dir = vldr.sp(signalp_dir) if options[:signalp_file] == nil


############# Converting input file to Bio::FastaFormat. #############
input_file = NpSearch::Input.new
input_read = input_file.read(options[:input], options[:input_type])

############# Extract_ORF #############
if options[:input_type].downcase == 'genetic'
  translater = NpSearch::Translation.new

  # Translate Sequences in all 6 frames
  translated_sequences = translater.translate(input_read)
  translated_sequences.to_fasta('translated sequences', 
                                "#{options[:output_dir]}/1_protein.fa") 

  # Extract all possible ORF that are longer than the ORF_min_length
  orf = translater.extract_orf(translated_sequences, options[:cut_off])
  orf.to_fasta('Open Reading Frames', "#{options[:output_dir]}/2_orf.fa")

  if options[:extract_orf]
    puts "\nSuccess: All output files created in the directory:" \
         "#{options[:output_dir]}'.\n " 
    exit
  end
end

############# Setting up more variables...##############
if options[:motif] == 'neuro_clv'
  motif = 'KK|KR|RR|'\
          'R..R|R....R|R......R|H..R|H....R|H......R|K..R|K....R|K......R'
else
  motif = options[:motif]
end

if options[:input_type].downcase == 'genetic'
  sp_input_file = "#{options[:output_dir]}/2_orf.fa"
  sp_hash = orf
  file_number = 3
else # i.e. if the input is protein 
  sp_input_file = options[:input]
  sp_hash = input_read
  file_number = 1
end

############# Running Signal P #############
signalp_test = NpSearch::Signalp.new
# Run an extenal Signal P script
if options[:signalp_file] == nil
  sp_out_file = "#{options[:output_dir]}/#{file_number}_signalp_out.txt"
  file_number += 1
  signalp_test.signalp(sp_dir, sp_input_file, sp_out_file)
end

############# Using the Signal P results file provided... #############
if options[:signalp_file] != nil 
  sp_out_file = options[:signalp_file]
  file_number = 1
end

############# Signal P Results Validation #############
# Check that the output produced is in a readable format
vldr.sp_results(sp_out_file)

############# Data Analysis #############
parser = NpSearch::Analysis.new
# extract sequences with a signal peptide 
secretome = parser.parse(sp_out_file, sp_hash, motif)
# Remove any duplicate data
flattened_seq = parser.flattener(secretome)

############# Creating Output Files #############
flattened_seq.to_fasta("fasta output file", 
                       "#{options[:output_dir]}/#{file_number}_output.fa")

to_output = NpSearch::Output.new
to_output.to_html(flattened_seq, motif, 
                  "#{options[:output_dir]}/#{file_number}_output.html")

############# Success #############
puts # a blank line.
puts "Success: All output files created in the directory:"\
    " '#{options[:output_dir]}'."
puts # a blank line.