#!/usr/bin/env ruby

require 'np_search/version'
require 'np_search'
require 'bio'
require 'fileutils'
require 'optparse'
require 'logger'
require 'haml'

# Search for the signal p directory with signal peptide.
signalp_dir = "#{Dir.home}/SignalPeptide"

options = {}
optparse = OptionParser.new do|opts|
  opts.banner =<<Banner

* Usage: np_search [Options] -m [Motif] -t [Input Type] -i [Input File] -o [Output Folder Name]

* Mandatory Options:

Banner

  options[:motif] = nil
  opts.on( '-m', '--motif [Query Motif]', 'The query motif to be searched for.',
           'The period "." can be used to denote any character. Multiple',
           'motifs query can be used by using a pipeline character ("|")',
           'between each query and putting the motif query in speech marks',
           'e.g. "KR|RR|R..R"',
           'Advanced Users: Regular expressions are also supported.') do |motif|
    options[:motif] = motif
  end

  options[:input_type] = nil
  opts.on( '-t', '--input_type [type]', 
           'The type of data in the input query file. The only two options',
           'available are "genetic" and "protein".') do |input_type|
    options[:input_type] = input_type
  end

  options[:input] = nil
  opts.on( '-i', '--input [file]', 
      'The input file. This can be a relative or a full path.') do |input_file|
    options[:input] = input_file
  end

  options[:output_dir] = nil
  opts.on( '-o', '--output [folder name]', 'The path to the output folder. This will be created if the folder does not already exist.') do |output|
    options[:output_dir] = output
  end

  opts.separator ''
  opts.separator '* Optional Options:'

  options[:cut_off] = 10
  opts.on( '-c', '--cut_off N', Integer, 'Changes the default minimum Open Reading Frame from 10 amino acid residues to N amino acid residues.') do |n|
    options[:cut_off] = n
  end

  options[:signalp_file] = nil
  opts.on( '-s', '--signalp_file [file]', 'Supply the output file of the Signal Peptide script (version 4.x) to the script.',
                'Otherwise the script will try to run the external Signal Peptide script when running.') do |signalp_file|
    options[:signalp_file] = signalp_file
  end

  options[:output_all] = false
  opts.on( '-a', '--output_all', 'Outputs all possible files.' ) do
    options[:output_all] = true
  end

  options[:extract_orf] = false
  opts.on( '-e', '--extract_orf', 'Only extracts the Open Reading Frames.' ) do
    options[:extract_orf] = true
  end

  options[:verbose] = false
  opts.on( '-v', '--verbose', 'Provides more information on each step taken'\
                              ' in this program.' ) do
    options[:verbose] = true
  end

  opts.on( '-h', '--help', 'Display this screen' ) do
    puts opts
    exit
  end

  opts.on( '--version', 'Shows version') do
    puts 
    exit
  end
end
optparse.parse!


############# Input Validation...##############
input_validators = NpSearch::Validators.new(options[:verbose])
input_validators.arg_validator(options[:motif], options[:input_type],
                               options[:input], options[:output_dir],
                               optparse.help())
if options[:signalp_file] == nil
  signalp_directory = input_validators.signalp_validator(signalp_dir)
end
input_validators.output_dir_validator(options[:output_dir])
input_validators.orf_min_length_validator(options[:cut_off])
input_validators.input_file_validator(options[:input])
input_validators.input_type_validator(options[:input_type])

### TODO: Convert the below into methods


if options[:input_type] == 'protein' && options[:extract_orf]
  puts 'Conflicting arguments detected: the Extract_ORF option (option "-e") ' \
       'is only available when input file contains protein data.'
  exit
end
if options[:input_type] == 'genetic' && options[:signalp_file] != nil
  puts 'Conflicting arguments detected: the signalp input option (option "-s")'\
        ' is only available when the input file contain protein data.'
  exit
end


############# Initialise Outputs...##############
to_output = NpSearch::Output.new

############# Converting input file to Bio::FastaFormat. #############
input_file = NpSearch::Input.new
input_read = input_file.read(options[:input], options[:input_type])

############# Extract_ORF #############
if options[:input_type].downcase == 'genetic'
  translater = NpSearch::Translation.new
  # Translate Sequences in all 6 frames
  translated_sequences = translater.translate(input_read)
  to_output.to_fasta('translated sequences', translated_sequences, "#{options[:output_dir]}/1_protein.fa") if options[:output_all]
  # Extract all possible ORF
  orf = translater.extract_orf(translated_sequences)
  to_output.to_fasta('extracted Open Reading Frames', orf, "#{options[:output_dir]}/2_orf.fa") if options[:output_all]
  # Remove all ORF that are shorter than 10 amino acids.
  j = 1 unless options[:output_all]
  j = 3 if options[:output_all] 
  orf_clean = translater.orf_cleaner(orf, options[:cut_off])
  to_output.to_fasta("cleaned Open Reading Frames" , orf_clean, "#{options[:output_dir]}/#{j}_orf_clean.fa") 
end

if options[:extract_orf]
  puts "\nSuccess: All output files created in the directory: '#{options[:output_dir]}'.\n " 
  exit
end

############# Setting up more variables...##############
if options[:motif] == 'neuro_clv'
  motif = 'KK|KR|RR|'\
          'R..R|R....R|R......R|H..R|H....R|H......R|K..R|K....R|K......R'
else
  motif = options[:motif]
end

if options[:input_type].downcase == 'genetic'
  signalp_input_file = "#{options[:output_dir]}/#{j}_orf_clean.fa" 
  signalp_hash = orf_clean
  i = j + 1  
else # i.e. if the input is protein 
  signalp_input_file = options[:input]
  signalp_hash = input_read
  i = 1
end

if options[:signalp_file] == nil
  signalp_out_file = "#{options[:output_dir]}/#{i}_signalp_out.txt"
  i += 1
else
  signalp_out_file = options[:signalp_file] 
  i = 1
end

############# Signal P #############
signalp_test = NpSearch::Signalp.new
# Run an extenal Signal P script
signalp_test.signalp(signalp_directory, signalp_input_file, signalp_out_file) if options[:signalp_file] == nil 
# Check that the output produced is in a readable format
input_validators.signalp_version_validator(signalp_out_file) 


############# Data Analysis #############
data_analysis = NpSearch::Analysis.new
identified_positives = data_analysis.signalp_positives_extractor(signalp_out_file, "#{options[:output_dir]}/#{i}_signalp_positives.txt", "signalp_positives_file")
signalp = data_analysis.array_generator(identified_positives)
secretome = data_analysis.parse(signalp, signalp_hash, motif)
i += 1
to_output.to_fasta("secretome", secretome, "#{options[:output_dir]}/#{i}_Secretome.fa")
i += 1

############# Creating Output Files #############
flattened_seq = data_analysis.flattener(secretome)
to_output.to_fasta("fasta output file", flattened_seq, "#{options[:output_dir]}/#{i}_output.fa")
html_hash = to_output.make_html_hash(flattened_seq, motif)
to_output.to_html(html_hash, "#{options[:output_dir]}/#{i}_output.doc")

# Success
puts "\nSuccess: All output files created in the directory: '#{options[:output_dir]}'.\n "