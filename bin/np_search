#!/usr/bin/env ruby

require 'bio'
require 'np_search/version'
require 'np_search'
require 'fileutils'
require 'optparse'
require 'logger'
require 'haml'

# Default Options
signalp_dir = "#{Dir.home}/SignalPeptide"                    
output_dir = "#{Dir.home}/output"                               
orf_min_length = 10

options = {}
optparse = OptionParser.new do|opts|
  opts.banner = 'Usage: np_search [options] InputFile InputType Motif'
  opts.separator 'Where:'
  opts.separator 'InputFile = The input query file'
  opts.separator 'InputType = The type of data in the input query file.' \
                 ' The only two options available are "genetic" and "protein"' 
  opts.separator 'Motif = The query motif to be searched for.'\
                 ' The period "." can be used to stands for any character.' \
                 ' Multiple motifs query can be used by using a pipeline' \
                 ' character ("|") between each query and putting the motif' \
                 'query in speech marks e.g. "KR|RR|R..R"'
  opts.separator 'Advanced Users: Regex is supported in the motif query'
  opts.separator ''
  opts.separator 'Options:'

  options[:verbose] = false
  opts.on( '-v', '--verbose', 'Provides more information on each step taken'\
                              ' in this program.' ) do
    options[:verbose] = true
  end

  options[:output_all] = false
  opts.on( '-a', '--output_all', 'Outputs all possible files' ) do
    options[:output_all] = true
  end
  
  options[:debug] = false
  opts.on( '-d', '--debug', 'Debugs the program' ) do
    options[:output_all] = true
  end
  
  opts.on( '-h', '--help', 'Display this screen' ) do
    puts opts
    exit
  end
end
optparse.parse!

unless ARGV.size == 3 
  puts # a blank line
  puts 'Incorrect number of Arguments'
  puts 'Usage: np_search.rb [options] InputFile InputType Motif'
  puts # a blank line
  puts 'Where:'
  puts 'InputFile = The input query file'
  puts 'InputType = The type of data in the input query file.' \
       'The only two options available are "genetic" and "protein"'
  puts 'Motif = The query motif to be searched for.' \
       'The period "." can be used to stands for any character.'
  puts '        Multiple motifs query can be used by using a pipeline' \
       ' character ("|") between each query and putting the motif query' \
       ' in speech marks.'
  puts '        For example the  motif query "KR|RR|R..R" will search for' \
       '"KR", "RR" and "R..R" (where . is any character)'
  puts 'Advanced Users: Regex is supported in the motif query'
  puts # a blank line
  puts 'Options:'
  puts '    -v, --verbose                    Provides more information on' \
       ' each step taken in this program.'
  puts '    -a, --output_all                 Out# puts all possible files'
  puts '    -h, --help                       Display this screen'
  puts # a blank line
  exit
end

input = ARGV[0] # e.g. 'example_files/genetic.fa'
input_type = ARGV[1] # e.g. 'genetic' or 'protein'
motif_query = ARGV[2] # e.g. 'neuro_clv'


if motif_query == 'neuro_clv'
  motif = 'KK|KR|RR|'\
          'R..R|R....R|R......R|H..R|H....R|H......R|K..R|K....R|K......R'
else
  motif = motif_query
end

logger = Logger.new(STDOUT)
logger.formatter = proc do |severity, datetime, progname, msg|
  "#{datetime}: #{msg}\n"
end
if options[:verbose]
  logger.level = Logger::INFO
elsif options[:debug]
  logger.level = Logger::DEBUG
else
  logger.level = Logger::FATAL
end

############# Input Validation...##############
input_validators_new = NpSearch::Validators.new 
signalp_directory = input_validators_new.signalp_validator(signalp_dir) 
input_validators_new.output_dir_validator(output_dir) 
input_validators_new.orf_min_length_validator(orf_min_length) 
input_validators_new.input_file_validator(input) 
input_validators_new.input_type_validator(input_type) 

# MAIN 
output_new = NpSearch::Output.new
if input_type.downcase == 'genetic'
  # Converting input file to Bio::FastaFormat.
logger.info { "Reading Input file: '#{input}'." }
  logger.info { "Reading Input file '#{input}'." } 
  input_new = NpSearch::Input.new
  input_read = input_new.read(input, input_type)

  # Translation
  translation_new = NpSearch::Translation.new
  logger.info { 'Translating the genomic data in all 6 frames.' }
  translated_sequences = translation_new.translate(input_read)
  logger.info { "Writing the translated sequences to the file:'#{output_dir}/protein.fa'." } if options[:output_all] 
  output_new.to_fasta(translated_sequences, "#{output_dir}/protein.fa") if options[:output_all] 
  # Open Reading Frame Extraction.
  logger.info { 'Extracting all Open Reading Frames from all 6 possible frames. This is every methionine residue to the next stop codon.' }
  orf = translation_new.extract_orf(translated_sequences)
  logger.info { "Writing the extracted Open Reading Frames to the file '#{output_dir}/orf.fa'." } if options[:output_all] 
  output_new.to_fasta(orf, "#{output_dir}/orf.fa") if options[:output_all] 
  logger.info { "Removing all Open Reading Frames that are shorter than #{orf_min_length}." }
  orf_condensed = translation_new.orf_cleaner(orf, orf_min_length)
  logger.info { "Writing the condensed Open Reading Frames to the file '#{output_dir}/orf_condensed.fa'." }
  output_new.to_fasta(orf_condensed, "#{output_dir}/orf_condensed.fa") 
  # Signal P
  signalp_new = NpSearch::Signalp.new
  logger.info { 'Running a Signal Peptide test on each condensed open reading frame.' }
  signalp_new.signal_p(signalp_directory, "#{output_dir}/orf_condensed.fa", "#{output_dir}/signalp_out.txt")
  input_validators_new.signalp_version_validator("#{output_dir}/signalp_out.txt")
elsif input_type.downcase == 'protein'
  logger.info { "Reading Input file '#{input}'." }
  # Signal P
  signalp_new = NpSearch::Signalp.new
  logger.info { 'Running a Signal Peptide test on each sequence.' }
  signalp_new.signal_p(signalp_directory, input, "#{output_dir}/signalp_out.txt")
end

# Data Analysis  (common for genetic and protein data)
logger.info { "Writing the Signal Peptide test results to the file" \
              " '#{output_dir}/signalp_out.txt'." }
if options[:output_all] 
  identified_positives_length = signalp_new.signalp_positives_extractor("#{output_dir}/signalp_out.txt", "#{output_dir}/signalp_positives.txt", "signalp_positives_file") 
elsif
  identified_positives_length = signalp_new.signalp_positives_extractor("#{output_dir}/signalp_out.txt", "#{output_dir}/signalp_positives.txt", "no_signalp_positives_file")
end
logger.info { 'Extracting all Open Reading Frames that have a Signal Peptide.' }

signalp = signalp_new.array_generator(identified_positives_length)

# Final Outputs. (more or less)
logger.info { 'Extracting sequences that have at least 1 neuropeptide cleavage site after the signal peptide cleavage site.' }
signalp_with_seq = signalp_new.parse(signalp, orf_condensed, motif)
logger.info { "Writing sequences that have at least 1 neuropeptide cleavage site after the signal peptide cleavage site to the file '#{output_dir}/signalp_with_seq.fa'." } if options[:output_all] 
output_new.to_fasta(signalp_with_seq, "#{output_dir}/signalp_with_seq.fa") if options[:output_all] 
logger.info { 'Removing all duplicate entries.' }
flattened_seq = signalp_new.flattener(signalp_with_seq)
logger.info { "Writing Ouput files to the fasta files '#{output_dir}/output.fa' and to the word document: '#{output_dir}/output.docx'." }
output_new.to_fasta(flattened_seq, "#{output_dir}/output.fa")

doc_hash = output_new.make_doc_hash(flattened_seq, motif)
output_new.to_doc(doc_hash, "#{output_dir}/output.docx")

# Success
puts "\nSuccess: All output files created in the directory: '#{output_dir}'.\n "
logger.close