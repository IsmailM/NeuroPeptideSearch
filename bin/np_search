#!/usr/bin/env ruby

require 'bio'
require 'np_search/version'
require 'np_search/validate'
require 'np_search'
require 'fileutils'
require 'optparse'
require 'logger'
require 'haml'

# Search for the signal p directory with signal peptide. 
signalp_dir = "#{Dir.home}/SignalPeptide"

help_banner = <<BANNER

Usage: np_search [options] InputType Motif InputFile Output_Prefix

Where:

InputType     = The type of data in the input query file. The only two options 
                available are "genetic" and "protein".
 
Motif         = The query motif to be searched for.
                The period "." can be used to denote any character. Multiple 
                motifs query can be used by using a pipeline character ("|")
                between each query and putting the motif query in speech marks 
                e.g. "KR|RR|R..R".
                Advanced Users: Regex is supported in the motif.

Input_File    = The input query file.

Output_Prefix = The Name of the output folder.

Options:

BANNER

options =<<OPTIONS 



OPTIONS

options = {}
optparse = OptionParser.new do|opts|
  opts.banner = help_banner

  options[:verbose] = false
  opts.on( '-v', '--verbose', 'Provides more information on each step taken'\
                              ' in this program.' ) do
    options[:verbose] = true
  end

  options[:output_all] = false
  opts.on( '-a', '--output_all', 'Outputs all possible files' ) do
    options[:output_all] = true
  end
  
  options[:debug] = false
  opts.on( '-d', '--debug', 'Debugs the program' ) do
    options[:debug] = true
  end
  
  opts.on( '-h', '--help', 'Display this screen' ) do
    puts opts
    exit
  end
end
optparse.parse!

unless ARGV.size == 4
  puts help_banner
  puts # a blank line
  puts options
  puts # a blank line
  exit
end

ORF_min_length = 10
input_type     = ARGV[0] # e.g. 'genetic' or 'protein' 
motif_query    = ARGV[1] # e.g. 'neuro_clv'
input          = ARGV[2] # e.g. 'example_files/genetic.fa'
output_dir     = ARGV[3]


if motif_query == 'neuro_clv'
  motif = 'KK|KR|RR|'\
          'R..R|R....R|R......R|H..R|H....R|H......R|K..R|K....R|K......R'
else
  motif = motif_query
end

logger = Logger.new(STDOUT)
logger.formatter = proc do |severity, datetime, progname, msg|
  "#{datetime}: #{msg}\n"
end
if options[:verbose]
  logger.level = Logger::INFO
elsif options[:debug]
  logger.level = Logger::DEBUG
else
  logger.level = Logger::FATAL
end

############# Input Validation...##############
input_validators_new = NpSearch::Validators.new 
  signalp_directory = input_validators_new.all_validators(signalp_dir, output_dir, ORF_min_length, input, input_type)

output_new = NpSearch::Output.new
if input_type.downcase == 'genetic'
  # Converting input file to Bio::FastaFormat.
  logger.info { "Reading Input file '#{input}'." } 
  input_new = NpSearch::Input.new
  input_read = input_new.read(input, input_type)

  # Translation
  translation_new = NpSearch::Translation.new
  logger.info { 'Translating the genomic data in all 6 frames.' }
  translated_sequences = translation_new.translate(input_read)
  logger.info { "Writing the translated sequences to the file:'#{output_dir}/protein.fa'." } if options[:output_all] 
  output_new.to_fasta(translated_sequences, "#{output_dir}/protein.fa") if options[:output_all] 
  # Open Reading Frame Extraction.
  logger.info { 'Extracting all Open Reading Frames from all 6 possible frames. This is every methionine residue to the next stop codon.' }
  orf = translation_new.extract_orf(translated_sequences)
  logger.info { "Writing the extracted Open Reading Frames to the file '#{output_dir}/orf.fa'." } if options[:output_all] 
  output_new.to_fasta(orf, "#{output_dir}/orf.fa") if options[:output_all] 
  logger.info { "Removing all Open Reading Frames that are shorter than #{ORF_min_length}." }
  orf_clean = translation_new.orf_cleaner(orf, ORF_min_length)
  logger.info { "Writing the cleaned Open Reading Frames to the file '#{output_dir}/orf_clean.fa'." }
  output_new.to_fasta(orf_clean, "#{output_dir}/orf_clean.fa") 
  # Signal P
  signalp_new = NpSearch::Signalp.new
  logger.info { 'Running a Signal Peptide test on each clean open reading frame.' }
  signalp_new.signal_p(signalp_directory, "#{output_dir}/orf_clean.fa", "#{output_dir}/signalp_out.txt")
  input_validators_new.signalp_version_validator("#{output_dir}/signalp_out.txt")
elsif input_type.downcase == 'protein'
  logger.info { "Reading Input file '#{input}'." }
  # Signal P
  signalp_new = NpSearch::Signalp.new
  logger.info { 'Running a Signal Peptide test on each sequence.' }
  signalp_new.signal_p(signalp_directory, input, "#{output_dir}/signalp_out.txt")
end

# Data Analysis  (common for genetic and protein data)
logger.info { "Writing the Signal Peptide test results to the file" \
              " '#{output_dir}/signalp_out.txt'." }
if options[:output_all] 
  identified_positives_length = signalp_new.signalp_positives_extractor("#{output_dir}/signalp_out.txt", "#{output_dir}/signalp_positives.txt", "signalp_positives_file") 
elsif
  identified_positives_length = signalp_new.signalp_positives_extractor("#{output_dir}/signalp_out.txt", "#{output_dir}/signalp_positives.txt", "no_signalp_positives_file")
end
logger.info { 'Extracting all Open Reading Frames that have a Signal Peptide.' }

signalp = signalp_new.array_generator(identified_positives_length)

# Final Outputs. (more or less)
logger.info { 'Extracting sequences that have at least 1 neuropeptide cleavage site after the signal peptide cleavage site.' }
signalp_with_seq = signalp_new.parse(signalp, orf_clean, motif)
logger.info { "Writing sequences that have at least 1 neuropeptide cleavage site after the signal peptide cleavage site to the file '#{output_dir}/signalp_with_seq.fa'." } if options[:output_all] 
output_new.to_fasta(signalp_with_seq, "#{output_dir}/signalp_with_seq.fa") if options[:output_all] 
logger.info { 'Removing all duplicate entries.' }
flattened_seq = signalp_new.flattener(signalp_with_seq)
logger.info { "Writing Ouput files to the fasta files '#{output_dir}/output.fa' and to the word document: '#{output_dir}/output.doc'." }
output_new.to_fasta(flattened_seq, "#{output_dir}/output.fa")

doc_hash = output_new.make_doc_hash(flattened_seq, motif)
output_new.to_doc(doc_hash, "#{output_dir}/output.docx")

# Success
puts "\nSuccess: All output files created in the directory: '#{output_dir}'.\n "
logger.close